## Simple Web App Authentication

This is the most common authentication, in this scenario the user go to your web page and clicks a login button, then the user is redirected to a authorization agent (like Keycloak) for authentication, when he finish the user is redirected back to your webpage with a token.


## Authorization URL

For this type of login we would need the ``authorization_endpoint:`` endpoint from the [discovery endpoint](https://github.com/cesarvr/keycloak) and we need to construct the following URL:

```xml
 https://my-keycloak-server/auth/
 realms/demo-1/protocol/openid-connect/auth?
 response_type=code
 &client_id=my-client
 &redirect_uri=https%3A%2F%2Flocalhost%3A666%2F
 &scope=my-scope
 &state=state123
```

Where:
- **response_type**=code - Indicates that your server expects to receive an authorization code
- **client_id** - The client ID you received when you first created the application
- **redirect_uri** - Indicates the URI to return the user to after authorization is complete
- **scope** - One or more scope values indicating which parts of the user's account you wish to access
- **state** - A random string generated by your application, which you'll verify later


Let's write a function that generate this for us:

```js
let qs  = require('querystring')

function buildURL() {

    const realm = 'demo-1'

    let params = qs.stringify({
        response_type: 'code',
        client_id: 'my-client',
        scope: 'my-scope',
        state: 'state123'
    })

    return `https://my-keycloak-server/auth/realms/${realm}/protocol/openid-connect/auth?${params}`
}
```




## Login Page

Now we need to show the user a login web page like this one:


```js
var express = require('express')

var app = express()
const PORT = 8080


function askForCredentials({URL}) {
    return `<!DOCTYPE HTML>
            <html>
              <head>
                <title>Hello OAuth2</title>
              </head>
              <body>
                <h1> Register </h1>
                <a href="${URL}">Login</a>
              </body>
            </html>`
}


app.get('/', (req, res) => {
  let page = buildLoginPage({ URL: buildURL() })
  res.send(page)
})
```

![Login Page]()

Now when the user clicks login, he will be redirected to the authentication agent (Keycloak) that will take care of the authentication for us, our application is completely isolated from any details about security in general.

But there is something we are missing, we need to implement a way for Keycloak to inform our application of the success or failure.



## Handling Responses

Once Keycloak finish the authentication procedure he need to call us back with a token, this token works as a key that allow the user to access our services, to get this token we need two things we need an endpoint that understand the following protocol:

```
https://<our-service>/<our-endpoint>?code=AUTH_CODE_HERE&state=1234zyx
```

Where:

- **code** - The server returns the authorization code in the query string.
- **state** - The server returns the same state value that you passed.

> The state parameter generated by our service, that help us identify if our service was the once that initiate the authentication.


### Implementing Callback

To implement the callback we are going to write a simple endpoint:


```js
app.get('/login', (req, res) => {
    if(req.query.code)
        //if we got the code we can allow the user to use the service.
        // This is a good place to implement a redirect, passing the token.  
        res.send(`<h2> Access token is ${req.query.code} </h2>`)
    else
        res.send(`<h2> User not found </h2>`)
})
```

Now we need to inform Keycloak of our endpoint, so we go to the ``buildURL`` function and add a new parameter called ``redirect_uri`` like this:


```js
function buildURL() {
    const realm = 'demo-1'

    let params = qs.stringify({
        response_type: 'code',
        client_id: 'my-client',
        scope: 'my-scope',
        state: 'state123',
        redirect_uri: `${process.env['ROUTE'] || 'URL_NOT_FOUND'}login`
    })

    return `https://sso-testing-1.apps.tmagic-5e4a.openshiftworkshop.com/auth/realms/${realm}/protocol/openid-connect/auth?${params}`
}
```

Here basically we read an environment variable ``ROUTE`` with our hostname or DNS name.

We can try doing:

```sh
export ROUTE=http://localhost:8080
node index.js
```

But that's a boring example, let's try deploying this into OpenShift.


# Deploying To OpenShift

To deploy to OpenShift is very simple we just need to add a library called [okd-runner](https://www.npmjs.com/package/okd-runner):

```sh
npm install okd-runner --save
```

Add the library:

```js
let okd = require('okd-runner')
```

That's it now your applications should know how to deploy itself, by doing:

```sh
node index.js -c
â–¶ node index.js -c
Initializing...  ok
creating objects  ok
building  ok

   URL:  http://web-auth-testing-1.apps.my-openshift-cluster.com
   ....
   ....
   > web-auth@1.0.0 start /opt/app-root/src
   > node index.js

   listening for request in 8080
```

Once your application is deployed you will get back the route URL, this route define the entry point of your application in the cluster.

Now you need to define the ``ROUTE`` environment variable using that URL, assuming called your application ``web-auth`` it would be as follow:

```sh
oc set env deploy web-auth ROUTE=http://web-auth-testing-1.apps.my-openshift-cluster.com
```

Now your service should be able to handle basica OAuth2 authentication against Keycloak.
