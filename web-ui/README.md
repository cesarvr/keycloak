## OAuth2 Authentication Example

This is the most common authentication, in this scenario the user go to your web page and clicks a login button, then the user is redirected to a authorization agent (like Keycloak) for authentication, when he finish the user is redirected back to your webpage with a token.

### Discovery

OAuth2 specify an auto-discovery URL, in Keycloak this URL are basically built in this form:

```xml
 https://{Server}:{Port}/auth/realms/<your-realm>/.well-known/openid-configuration
```
This URL will return a list of endpoints required to use OAuth2 authentication:

```json

{
  "issuer":"https://my-keycloak-server/auth/realms/demo-1",
  "authorization_endpoint":".../auth",
  "token_endpoint":".../token",
  "token_introspection_endpoint":".../introspect",
  "userinfo_endpoint":".../userinfo",
  "end_session_endpoint":".../logout"
  "etc..."
}
```

### Hello World Nodejs

We can start by making a simple HTTP server using Javascript: 

```sh
 var express = require('express')
 var okd_runner = require('okd-runner')
 var app = express()
 
 app.get('/', (req, res) => res.send('<h1> Hello !</h1>') )

 console.log('listening in port 8080')
 app.listen(8080)
```

We save this into ``index.js``. 


#### Testing Locally

After we save it we need to install two libraries:
 - ``express`` server framework. 
 - ``okd-runner`` make this application self-deployable to OpenShift.  

```sh
 npm install express okd-runner --save
```

Now we can test it locally:

```sh
node index.js
# listening in port 8080
```

### Login Page

Now that we got our server running let's add a small **login** webpage:  

```js
var express = require('express')

var app = express()
const PORT = 8080

function askForCredentials({URL}) {
    return `<!DOCTYPE HTML>
            <html>
              <head>
                <title>Hello OAuth2</title>
              </head>
              <body>
                <h1> Register </h1>
                <a href="${URL}">Login</a>
              </body>
            </html>`
}

app.get('/', (req, res) => {
  let page = buildLoginPage({ URL: 'http://test.com' })
  res.send(page)
})
```

If we run our server again we should see a nice login page. 

![Login Page](https://github.com/cesarvr/keycloak-examples/blob/master/web-ui/docs/login.png?raw=true)



### Asking For Authorization 

Now we need to delegate the authentication process to RedHat SSO, after all we don't want our service to know anything about this, so we can achieve this by redirecting the user via our **login** page to an especific kecloak endpoint called ``authorization_endpoint``, you can find this endpoint in the [discovery payload](https://github.com/cesarvr/keycloak-examples/tree/master/web-ui#discovery). 

We need to call this URL like this:

```
 https://my-keycloak-server/auth/realms/demo-1/protocol/openid-connect/auth?response_type=...
```

With this [query parameters](https://en.wikipedia.org/wiki/Query_string):

```xml
...auth?response_type=code
 &client_id=my-client
 &redirect_uri=https%3A%2F%2Flocalhost%3A666%2F
 &scope=my-scope
 &state=state123
```

Where:
- **response_type**=code - Indicates that your server expects to receive an authorization code
- **client_id** - You need to [register a client in RHSSO](https://www.keycloak.org/docs/latest/getting_started/index.html#creating-and-registering-the-client), usually the name of the client is the client ID.

![](https://www.keycloak.org/docs/latest/getting_started/keycloak-images/clients.png)
- **redirect_uri** - Indicates the URI to return the user to after authorization is complete, make sure you set the right redirect address for your [client](https://www.keycloak.org/docs/latest/getting_started/index.html#creating-and-registering-the-client).

![](https://i.stack.imgur.com/IMEhn.png)

> Arterisk (*), means that we accept any URL pattern as redirect URI. 

- **scope** - One or more scope values indicating which parts of the user's account you wish to access
- **state** - A random string generated by your application, which you'll verify later to be sure your service is the initiator of this request. 


Let's write a function that generate this link for us:

```js
let qs  = require('querystring')

function buildURL() {

    const realm = 'demo-1'

    let params = qs.stringify({
        response_type: 'code',
        client_id: 'my-client',
        scope: 'photos',
        state: 'state123'
    })

    return `https://my-keycloak-server/auth/realms/${realm}/protocol/openid-connect/auth?${params}`
}
```

This function will craft an URL, so now let's pass this URL to our **login** screen link: 

```sh
app.get('/', (req, res) => {
  let page = buildLoginPage({ URL:  buildURL() })
  res.send(page)
})
```

Now we execute our server again: 

We are going to see our Login page: 

![Login Page](https://github.com/cesarvr/keycloak-examples/blob/master/web-ui/docs/login.png?raw=true)

But if we click we are going to get redirected to: 

![keycloak](https://github.com/cesarvr/keycloak-examples/blob/master/docs/Screenshot%202019-05-03%20at%2012.42.30.png?raw=true)

This is the Red Hat SSO login page for this realm. 

## Handling Responses

Once the user finish the authentication the Keycloak server following the OAuth2 protocol wil use the value of ``redirect_uri`` to call us back, the problem is that this only work is our application is visible, to do that let's assume we have a OpenShift cluster running in the cloud, so let's proceed to :

```
https://<our-service>/<our-endpoint>?code=AUTH_CODE_HERE&state=1234zyx
```

Where:

- **code** - The server returns the authorization code in the query string.
- **state** - The server returns the same state value that you passed.

> The state parameter generated by our service, that help us identify if our service was the once that initiate the authentication.


### Implementing Callback

To implement the callback we are going to write a simple endpoint:


```js
app.get('/login', (req, res) => {
    if(req.query.code)
        //if we got the code we can allow the user to use the service.
        // This is a good place to implement a redirect, passing the token.  
        res.send(`<h2> Access token is ${req.query.code} </h2>`)
    else
        res.send(`<h2> User not found </h2>`)
})
```

Now we need to inform Keycloak of our endpoint, so we go to the ``buildURL`` function and add a new parameter called ``redirect_uri`` like this:


```js
function buildURL() {
    const realm = 'demo-1'

    let params = qs.stringify({
        response_type: 'code',
        client_id: 'my-client',
        scope: 'photos',
        state: 'state123',
        redirect_uri: `${process.env['ROUTE'] || 'URL_NOT_FOUND'}login`
    })

    return `https://sso-testing-1.apps.tmagic-5e4a.openshiftworkshop.com/auth/realms/${realm}/protocol/openid-connect/auth?${params}`
}
```

Here basically we read an environment variable ``ROUTE`` with our hostname or DNS name.

We can try doing:

```sh
export ROUTE=http://localhost:8080
node index.js
```

But that's a boring example, let's try deploying this into OpenShift.


# Deploying To OpenShift

To deploy to OpenShift is very simple we just need to add a library called [okd-runner](https://www.npmjs.com/package/okd-runner):

```sh
npm install okd-runner --save
```

Add the library:

```js
let okd = require('okd-runner')
```

That's it, now your applications should know how to deploy itself, now you just need to execute:

```sh
node index.js -c
â–¶ node index.js -c
Initializing...  ok
creating objects  ok
building  ok

   URL:  http://web-auth-testing-1.apps.my-openshift-cluster.com
   ....
   ....
   > web-auth@1.0.0 start /opt/app-root/src
   > node index.js

   listening for request in 8080
```

Once your application is deployed you will get back the route URL, this route define the entry point of your application in the cluster.

Now you need to define the ``ROUTE`` environment variable using that URL, assuming called your application ``web-auth`` it would be as follow:

```sh
oc set env deploy web-auth ROUTE=http://web-auth-testing-1.apps.my-openshift-cluster.com
```

Now your service should be able to handle basica OAuth2 authentication against Keycloak.



For more information about OAuth2 go to [this site](https://aaronparecki.com/oauth-2-simplified/).

